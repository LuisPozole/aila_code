import requests
import numpy as np
import queue
import google.generativeai as genai
import wave
import io
import pygame
import sounddevice as sd
import json
import time
import os
import threading
from pymongo import MongoClient
from vosk import Model, KaldiRecognizer
from gtts import gTTS
from flask import Flask, request

# ConfiguraciÃ³n de la API de Gemini
genai.configure(api_key="AIzaSyDSPU3HTfAB_jnIwi--8yhBGzUtUVs5N6U")
model = genai.GenerativeModel("gemini-1.5-flash")

# ConfiguraciÃ³n de MongoDB
MONGO_URI = "mongodb+srv://Luis:XahmSNY8h2ykcQEA@aila.ilku2.mongodb.net/Aila"
DATABASE_NAME = "Aila"
COLLECTION_NAME = "Usuarios"

def obtener_contactos():
    try:
        client = MongoClient(MONGO_URI)
        db = client[DATABASE_NAME]
        collection = db[COLLECTION_NAME]
        usuario = collection.find_one({"email": "kykesaco@gmail.com"})
        if usuario and "contacto" in usuario:
            contactos = {c["nombre"].lower(): c["telefono"] for c in usuario["contacto"]}
            print("ðŸ“² Contactos cargados:", contactos)
            return contactos
        else:
            print("âš ï¸ No se encontraron contactos para el usuario.")
            return {}
    except Exception as e:
        print("âŒ Error conectando a MongoDB:", e)
        return {}

contactos = obtener_contactos()

# ConfiguraciÃ³n de audio
samplerate = 50000
duration = 5
channels = 1
q = queue.Queue()
pygame.mixer.init(frequency=44100, size=-16, channels=1, buffer=512)

applause_threshold = 0.03

VOSK_MODEL_PATH = "/home/pi/vosk-model-small-es-0.42"
vosk_model = Model(VOSK_MODEL_PATH)

def callback(indata, frames, time, status):
    if status:
        print(status)
    q.put(indata.copy())

def grabar_audio(archivo_salida="input.wav"):
    print("ðŸŽ¤ Grabando audio...")
    with sd.InputStream(samplerate=samplerate, channels=channels, callback=callback):
        audio_data = []
        for _ in range(int(samplerate / 1024 * duration)):
            audio_data.append(q.get())
        audio_np = np.concatenate(audio_data, axis=0)

    audio_np = (audio_np * 32767).astype(np.int16)
    with wave.open(archivo_salida, "wb") as wf:
        wf.setnchannels(channels)
        wf.setsampwidth(2)
        wf.setframerate(samplerate)
        wf.writeframes(audio_np.tobytes())
    print("âœ… Audio guardado como", archivo_salida)
    return archivo_salida

def transcribir_audio(archivo):
    print("ðŸ“ Transcribiendo con Vosk...")
    with wave.open(archivo, "rb") as wf:
        rec = KaldiRecognizer(vosk_model, wf.getframerate())
        rec.SetWords(True)
        while True:
            data = wf.readframes(4000)
            if len(data) == 0:
                break
            rec.AcceptWaveform(data)
        resultado = json.loads(rec.FinalResult())
        return resultado.get("text", "")

def obtener_respuesta(texto):
    print(f"ðŸ¤– Enviando a Gemini: {texto}")
    response = model.generate_content(texto)
    return response.text if response and response.text else "Lo siento, no entendÃ­."

def hablar(texto):
    print("ðŸ”Š Generando voz...")
    tts = gTTS(texto, lang="es")
    audio_stream = io.BytesIO()
    tts.write_to_fp(audio_stream)
    audio_stream.seek(0)
    with open("temp_audio.mp3", "wb") as f:
        f.write(audio_stream.read())
    pygame.mixer.music.load("temp_audio.mp3")
    pygame.mixer.music.play()
    while pygame.mixer.music.get_busy():
        pygame.time.wait(100)
    audio_stream.close()

def enviar_mensaje_whatsapp(numero, mensaje):
    url = "http://localhost:3000/enviar-mensaje"
    payload = {"numero": numero, "mensaje": mensaje}
    try:
        response = requests.post(url, json=payload)
        if response.status_code == 200:
            print(f"âœ… Mensaje enviado a {numero}")
            return "Mensaje enviado exitosamente."
        else:
            print(f"âŒ Error enviando mensaje: {response.text}")
            return "Hubo un error al enviar el mensaje."
    except Exception as e:
        print(f"âš ï¸ Error de conexiÃ³n: {e}")
        return "No pude conectar con el servidor de mensajes."

def detectar_aplauso():
    print("ðŸ‘ Esperando aplauso para activar AILA...")
    while True:
        audio = sd.rec(int(samplerate * 0.5), samplerate=samplerate, channels=1, dtype="float32")
        sd.wait()
        volumen = np.sqrt(np.mean(audio**2))
        if volumen > applause_threshold:
            print("âœ… APLAUSO DETECTADO: AILA ACTIVADA ðŸ”¥")
            return True

def procesar_comando(texto):
    global contactos
    contactos = obtener_contactos()
    if "envia un mensaje" in texto:
        hablar("Â¿A quiÃ©n quieres enviar un mensaje?")
        nombre = transcribir_audio(grabar_audio()).strip().lower()
        if nombre in contactos:
            hablar(f"Â¿QuÃ© quieres decirle a {nombre}?")
            mensaje = transcribir_audio(grabar_audio()).strip()
            if mensaje:
                respuesta = enviar_mensaje_whatsapp(contactos[nombre], mensaje)
                hablar(respuesta)
            else:
                hablar("No entendÃ­ el mensaje. IntÃ©ntalo de nuevo.")
        else:
            hablar(f"No tengo registrado a {nombre} en mi lista de contactos.")
    else:
        respuesta = obtener_respuesta(texto)
        hablar(respuesta)

def main():
    hablar("Hola! Soy AILA, y estoy aquÃ­ para ayudarte. Solo estoy a un aplauso de distancia.")
    while True:
        if detectar_aplauso():
            archivo_audio = grabar_audio()
            texto = transcribir_audio(archivo_audio)
            if texto.strip():
                procesar_comando(texto)
            else:
                print("âš  No se detectÃ³ ningÃºn mensaje, intenta de nuevo.")

app = Flask(__name__)
@app.route("/nuevo-mensaje", methods=["POST"])
def nuevo_mensaje():
    data = request.json
    numero = data.get("numero", "Desconocido")
    mensaje = data.get("mensaje", "")
    if mensaje:
        threading.Thread(target=hablar, args=(f"Nuevo mensaje de {numero}: {mensaje}",)).start()
    return {"status": "ok"}

def iniciar_servidor():
    app.run(host="0.0.0.0", port=5000, debug=False, use_reloader=False)

if __name__ == "__main__":
    threading.Thread(target=iniciar_servidor, daemon=True).start()
    main()
